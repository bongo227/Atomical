enum class CompareType {
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,
    LessThanOrEqualTo,
    MoreThanOrEqualTo
};

// typedef enum {
    //     RETURN, 
    //     BRANCH, 
    //     ADD, 
    //     SUB, 
    //     MUL, 
    //     DIV, 
    //     SHIFT_LEFT, 
    //     SHIFT_RIGHT, 
    //     AND, 
    //     OR, 
    //     XOR, 
    //     CAST, 
    //     COMPARE, 
    //     PHI 
    // } InstructionType;

    // InstructionType instruction_type;
    
    // union {
    //     Value ret;
    //     BasicBlock *br;
    //     struct { Value lhs; Value rhs; } binary;
    //     struct { Type *type; Value value; } cast;
    //     std::vector<std::tuple<BasicBlock *, Value>> phi;
    // };


    // // TODO: collapse into flags
    // // CompareType compare_type;
    // // bool instruction_ordered;
    // // bool instruction_unsigned;

    // private:
    //     Instruction(Value value) : 
    //         ret(value), instruction_type(InstructionType::RETURN) {}
    //     Instruction(BasicBlock *destination) : 
    //         br(destination), instruction_type(InstructionType::BRANCH) {}
    //     Instruction(Value lhs, Value rhs, InstructionType type) : 
    //         binary{lhs, rhs}, instruction_type(type) {}
    //     Instruction(Type *type, Value value) : 
    //         cast{type, value}, instruction_type(InstructionType::CAST) {}
    //     Instruction(std::vector<std::tuple<BasicBlock *, Value>> incoming) : 
    //         phi(incoming) {}

    // public:
    //     static Instruction Return(Value value) 
    //         { return Instruction(param, value); }
    //     static Instruction Branch(BasicBlock *destination) 
    //         { return Instruction(param, destination); }
    //     static Instruction Add(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::ADD); }
    //     static Instruction Sub(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::SUB); }
    //     static Instruction Mul(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::MUL); }
    //     static Instruction Div(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::DIV); }
    //     static Instruction ShiftLeft(Value lhs, Value rhs) 
    //         { return Instruction(param, lhs, rhs, InstructionType::SHIFT_LEFT); }
    //     static Instruction ShiftRight(Value lhs, Value rhs) 
    //         { return Instruction(param, lhs, rhs, InstructionType::SHIFT_RIGHT); }
    //     static Instruction And(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::AND); }
    //     static Instruction Or(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::OR); }
    //     static Instruction Xor(Value lhs, Value rhs)
    //         { return Instruction(param, lhs, rhs, InstructionType::XOR); }
    //     static Instruction Cast(Type *type, Value value) 
    //         { return Instruction(param, type, value); }
    //     static Instruction Phi(std::vector<std::tuple<BasicBlock *, Value>> incoming)
    //         { return Instruction(param, incoming); }